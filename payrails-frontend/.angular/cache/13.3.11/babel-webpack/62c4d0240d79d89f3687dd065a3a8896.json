{"ast":null,"code":"import _asyncToGenerator from \"/Users/ahmedyehiakhater/payrails-product-assessment/payrails-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@payrails/web-cse\";\nexport class EncryptionService {\n  constructor(ngZone, payrailsCSE) {\n    this.ngZone = ngZone;\n    this.payrailsCSE = payrailsCSE;\n  } // clientSideEncryption(creditCardModel: any, publicKey: any) {\n  //   const cse = PayrailsCSE.init(publicKey);\n  //   console.log(\"CSE\", cse);\n  // }\n\n  /**\n   * The following is in case we need to encrypt using encryption algorithm RSA-OAEP-256 and content encryption A256CBC-HS512 but without JWE - this should be done strictly from server side\n   * @param creditCardModel\n   * @param publicKey\n   * @returns\n   */\n\n\n  encryptCreditCard(creditCardModel, publicKey) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const cryptoKey = yield _this.importKey(publicKey);\n      const encodedText = new TextEncoder().encode(JSON.stringify(creditCardModel)); // Use NgZone.run to ensure that change detection is aware of the asynchronous operation\n\n      return _this.ngZone.run( /*#__PURE__*/_asyncToGenerator(function* () {\n        const encryptedData = yield crypto.subtle.encrypt({\n          name: 'RSA-OAEP'\n        }, cryptoKey, encodedText);\n        return btoa(String.fromCharCode(...new Uint8Array(encryptedData)));\n      }));\n    })();\n  } // Import the public key for encryption\n\n\n  importKey(publicKey) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Convert the base64-encoded public key to an ArrayBuffer\n      const keyBuffer = yield crypto.subtle.importKey('spki', _this2.base64ToArrayBuffer(publicKey), {\n        name: 'RSA-OAEP',\n        hash: 'SHA-256'\n      }, true, ['encrypt']);\n      return keyBuffer;\n    })();\n  } // Convert a base64-encoded string to an ArrayBuffer\n\n\n  base64ToArrayBuffer(base64) {\n    const binaryString = window.atob(base64);\n    const len = binaryString.length;\n    const bytes = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n\n    return new Uint8Array(bytes).buffer;\n  }\n\n}\n\nEncryptionService.ɵfac = function EncryptionService_Factory(t) {\n  return new (t || EncryptionService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.PayrailsCSE));\n};\n\nEncryptionService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: EncryptionService,\n  factory: EncryptionService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["/Users/ahmedyehiakhater/payrails-product-assessment/payrails-frontend/src/app/services/encryption.service.ts"],"names":["i0","i1","EncryptionService","constructor","ngZone","payrailsCSE","encryptCreditCard","creditCardModel","publicKey","cryptoKey","importKey","encodedText","TextEncoder","encode","JSON","stringify","run","encryptedData","crypto","subtle","encrypt","name","btoa","String","fromCharCode","Uint8Array","keyBuffer","base64ToArrayBuffer","hash","base64","binaryString","window","atob","len","length","bytes","Array","i","charCodeAt","buffer","ɵfac","EncryptionService_Factory","t","ɵɵinject","NgZone","PayrailsCSE","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":";AAAA,OAAO,KAAKA,EAAZ,MAAoB,eAApB;AACA,OAAO,KAAKC,EAAZ,MAAoB,mBAApB;AACA,OAAO,MAAMC,iBAAN,CAAwB;AAC3BC,EAAAA,WAAW,CAACC,MAAD,EAASC,WAAT,EAAsB;AAC7B,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACH,GAJ0B,CAK3B;AACA;AACA;AACA;;AACA;AACJ;AACA;AACA;AACA;AACA;;;AACUC,EAAAA,iBAAiB,CAACC,eAAD,EAAkBC,SAAlB,EAA6B;AAAA;;AAAA;AAChD,YAAMC,SAAS,SAAS,KAAI,CAACC,SAAL,CAAeF,SAAf,CAAxB;AACA,YAAMG,WAAW,GAAG,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyBC,IAAI,CAACC,SAAL,CAAeR,eAAf,CAAzB,CAApB,CAFgD,CAGhD;;AACA,aAAO,KAAI,CAACH,MAAL,CAAYY,GAAZ,iCAAgB,aAAY;AAC/B,cAAMC,aAAa,SAASC,MAAM,CAACC,MAAP,CAAcC,OAAd,CAAsB;AAC9CC,UAAAA,IAAI,EAAE;AADwC,SAAtB,EAEzBZ,SAFyB,EAEdE,WAFc,CAA5B;AAGA,eAAOW,IAAI,CAACC,MAAM,CAACC,YAAP,CAAoB,GAAG,IAAIC,UAAJ,CAAeR,aAAf,CAAvB,CAAD,CAAX;AACH,OALM,EAAP;AAJgD;AAUnD,GAzB0B,CA0B3B;;;AACMP,EAAAA,SAAS,CAACF,SAAD,EAAY;AAAA;;AAAA;AACvB;AACA,YAAMkB,SAAS,SAASR,MAAM,CAACC,MAAP,CAAcT,SAAd,CAAwB,MAAxB,EAAgC,MAAI,CAACiB,mBAAL,CAAyBnB,SAAzB,CAAhC,EAAqE;AACzFa,QAAAA,IAAI,EAAE,UADmF;AAEzFO,QAAAA,IAAI,EAAE;AAFmF,OAArE,EAGrB,IAHqB,EAGf,CAAC,SAAD,CAHe,CAAxB;AAIA,aAAOF,SAAP;AANuB;AAO1B,GAlC0B,CAmC3B;;;AACAC,EAAAA,mBAAmB,CAACE,MAAD,EAAS;AACxB,UAAMC,YAAY,GAAGC,MAAM,CAACC,IAAP,CAAYH,MAAZ,CAArB;AACA,UAAMI,GAAG,GAAGH,YAAY,CAACI,MAAzB;AACA,UAAMC,KAAK,GAAG,IAAIC,KAAJ,CAAUH,GAAV,CAAd;;AACA,SAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,GAApB,EAAyBI,CAAC,EAA1B,EAA8B;AAC1BF,MAAAA,KAAK,CAACE,CAAD,CAAL,GAAWP,YAAY,CAACQ,UAAb,CAAwBD,CAAxB,CAAX;AACH;;AACD,WAAO,IAAIZ,UAAJ,CAAeU,KAAf,EAAsBI,MAA7B;AACH;;AA5C0B;;AA8C/BrC,iBAAiB,CAACsC,IAAlB,GAAyB,SAASC,yBAAT,CAAmCC,CAAnC,EAAsC;AAAE,SAAO,KAAKA,CAAC,IAAIxC,iBAAV,EAA6BF,EAAE,CAAC2C,QAAH,CAAY3C,EAAE,CAAC4C,MAAf,CAA7B,EAAqD5C,EAAE,CAAC2C,QAAH,CAAY1C,EAAE,CAAC4C,WAAf,CAArD,CAAP;AAA2F,CAA5J;;AACA3C,iBAAiB,CAAC4C,KAAlB,GAA0B,aAAc9C,EAAE,CAAC+C,kBAAH,CAAsB;AAAEC,EAAAA,KAAK,EAAE9C,iBAAT;AAA4B+C,EAAAA,OAAO,EAAE/C,iBAAiB,CAACsC,IAAvD;AAA6DU,EAAAA,UAAU,EAAE;AAAzE,CAAtB,CAAxC","sourcesContent":["import * as i0 from \"@angular/core\";\nimport * as i1 from \"@payrails/web-cse\";\nexport class EncryptionService {\n    constructor(ngZone, payrailsCSE) {\n        this.ngZone = ngZone;\n        this.payrailsCSE = payrailsCSE;\n    }\n    // clientSideEncryption(creditCardModel: any, publicKey: any) {\n    //   const cse = PayrailsCSE.init(publicKey);\n    //   console.log(\"CSE\", cse);\n    // }\n    /**\n     * The following is in case we need to encrypt using encryption algorithm RSA-OAEP-256 and content encryption A256CBC-HS512 but without JWE - this should be done strictly from server side\n     * @param creditCardModel\n     * @param publicKey\n     * @returns\n     */\n    async encryptCreditCard(creditCardModel, publicKey) {\n        const cryptoKey = await this.importKey(publicKey);\n        const encodedText = new TextEncoder().encode(JSON.stringify(creditCardModel));\n        // Use NgZone.run to ensure that change detection is aware of the asynchronous operation\n        return this.ngZone.run(async () => {\n            const encryptedData = await crypto.subtle.encrypt({\n                name: 'RSA-OAEP',\n            }, cryptoKey, encodedText);\n            return btoa(String.fromCharCode(...new Uint8Array(encryptedData)));\n        });\n    }\n    // Import the public key for encryption\n    async importKey(publicKey) {\n        // Convert the base64-encoded public key to an ArrayBuffer\n        const keyBuffer = await crypto.subtle.importKey('spki', this.base64ToArrayBuffer(publicKey), {\n            name: 'RSA-OAEP',\n            hash: 'SHA-256',\n        }, true, ['encrypt']);\n        return keyBuffer;\n    }\n    // Convert a base64-encoded string to an ArrayBuffer\n    base64ToArrayBuffer(base64) {\n        const binaryString = window.atob(base64);\n        const len = binaryString.length;\n        const bytes = new Array(len);\n        for (let i = 0; i < len; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n        }\n        return new Uint8Array(bytes).buffer;\n    }\n}\nEncryptionService.ɵfac = function EncryptionService_Factory(t) { return new (t || EncryptionService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.PayrailsCSE)); };\nEncryptionService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: EncryptionService, factory: EncryptionService.ɵfac, providedIn: 'root' });\n"]},"metadata":{},"sourceType":"module"}